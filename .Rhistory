colMeans(Str)
Std <- tibble(
mes.1 <- c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 <- c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 <- c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 <- c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371)
)
colMeans(Std)
rowMeans(Std)
map_dfc(Std, mean())
map_dfc(Std, mean
map_dfc(Std, mean)
map_dfc(Std, mean)
pmap(Std, mean)
pmap(Std, mean)
pmap(Std[1:4], mean)
Std <- tibble(
mes.1 <- c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 <- c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 <- c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 <- c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
rowMeans(Std)
)
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
In diesem Intro werden wir mit dem Paket Biotech arbeiten, dieses installieren wir mit:
```{r message=FALSE}
devtools::install_github("https://github.com/Utzi1/Biotech")
```
Installieren müssen wir es nur ein Mal, danach jedoch müssen wir in jedem Skript, in welchem es zum Einsatz kommt, auf seine Existenz verweisen, wir müssen es "laden":
```{r}
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
```
# Eine Konzentrationsbestimmung
Ihr habt im Labor den Bradfor-Assy durchgeführt und mit Rinderserumalbumin eine Standardreihe aufgenommen, dazu wurden zu jeder Verdünnung vier technische Replikate angefertigt und deren Absorption gemäß der Vorschrift gemessen.
Die Ergebnisse der Messung lauten:
````{r}
Std <- tibble(
mes.1 <- c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 <- c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 <- c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 <- c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
rowMeans(Std)
)
````
Diese fassen wir gleich als tibble zusammen.
Zusätzlich dazu brauchen wir eine Vector, welcher Information über die Konzentration des BSA in den angesetzten Standards bereithält:
```{r}
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(mes.1)
)
```
Die Länge (also Anzahl der einzelnen Werte muss der Anzahl der Standards entsprechen) wird über das Argument length.out gesteuert.
Als Nächstes berechnen wir das arithmetische Mittel der technischen Replikate:
```{r}
Std <- tibble(
mes.1 <- c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 <- c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 <- c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 <- c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
rowMeans(Std)
)
knitr::opts_chunk$set(echo = TRUE)
Std.mean <- rowMeans(Std)
knitr::opts_chunk$set(echo = TRUE)
devtools::install_github("https://github.com/Utzi1/Biotech")
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
Std <- tibble(
mes.1 <- c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 <- c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 <- c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 <- c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(mes.1)
)
knitr::opts_chunk$set(echo = TRUE)
devtools::install_github("https://github.com/Utzi1/Biotech")
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
Std <- tibble(
mes.1 <- c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 <- c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 <- c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 <- c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
Std.mean <- rowMeans(Std)
plot_regression(abs = Std.mean, conc = conc)
Std.mean <- rowMeans(Std)
plot_regression(abs = Std.mean, conc = conc)
plot_regression(abs = Std.mean, conc = conc)
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
Std <- tibble(
mes.1 <- c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 <- c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 <- c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 <- c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
Std <- tibble(
mes.1 = c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 = c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 = c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 = c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
Std <- tibble(
mes.1 = c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 = c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 = c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 = c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
Ihr habt im Labor den Bradfor-Assy durchgeführt und mit Rinderserumalbumin eine Standardreihe aufgenommen, dazu wurden zu jeder Verdünnung vier technische Replikate angefertigt und deren Absorption gemäß der Vorschrift gemessen.
Die Ergebnisse der Messung lauten:
````{r}
Std <- tibble(
mes.1 = c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 = c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 = c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 = c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
````
Diese fassen wir gleich als tibble zusammen.
Zusätzlich dazu brauchen wir eine Vector, welcher Information über die Konzentration des BSA in den angesetzten Standards bereithält:
```{r}
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$)
)
```
Die Länge (also Anzahl der einzelnen Werte muss der Anzahl der Standards entsprechen) wird über das Argument length.out gesteuert.
Als Nächstes berechnen wir das arithmetische Mittel der technischen Replikate:
```{r}
Std.mean <- rowMeans(Std)
```
Damit haben wir nun alles um ein lineares Modell vom Typ $y = m \cdot x + b$ zu errechnen und zu plotten, dies geht recht leicht:
```{r}
plot_regression(abs = Std.mean, conc = conc)
```
Std <- tibble(
mes.1 = c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 = c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 = c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 = c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
Ihr habt im Labor den Bradfor-Assy durchgeführt und mit Rinderserumalbumin eine Standardreihe aufgenommen, dazu wurden zu jeder Verdünnung vier technische Replikate angefertigt und deren Absorption gemäß der Vorschrift gemessen.
Die Ergebnisse der Messung lauten:
````{r}
Std <- tibble(
mes.1 = c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 = c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 = c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 = c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
````
Diese fassen wir gleich als tibble zusammen.
Zusätzlich dazu brauchen wir eine Vector, welcher Information über die Konzentration des BSA in den angesetzten Standards bereithält:
```{r}
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
```
Die Länge (also Anzahl der einzelnen Werte muss der Anzahl der Standards entsprechen) wird über das Argument length.out gesteuert.
Als Nächstes berechnen wir das arithmetische Mittel der technischen Replikate:
```{r}
Std.mean <- rowMeans(Std)
```
Damit haben wir nun alles um ein lineares Modell vom Typ $y = m \cdot x + b$ zu errechnen und zu plotten, dies geht recht leicht:
```{r}
plot_regression(abs = Std.mean, conc = conc)
```
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
Std.mean <- rowMeans(Std)
plot_regression(abs = Std.mean, conc = conc)
lm(conc~Std.mean)
lm(conc~Std.mean) %>%
summarise()
lm(conc~Std.mean) %>%
summarise()
lm(conc~Std.mean) %>%
summary()
lm(x =conc, y = Std.mean) %>%
summary()
lm(x =conc, y = Std.mean) %>%
summary()
lm(x =conc, y = Std.mean) %>%
summary()
lm(Std.mean~conc) %>%
summary()
plot_regression(abs = Std.mean, conc = conc)
View(LinMod_CEv)
View(LinMod_CEv)
# Berechnen des Modells
LinMod_CEv(abs = Std.mean, conc = conc)
#'
#' This must be performed in advanvce of usage of the function conc_eval to produce a linear model suiteable
#' for concentration evaluation.
#'
#' @param abs list
#' @param conc list
#'
#' @return Dataframe
#' @export
#'
LinMod <- function(abs, conc) {
return(
stats::lm(
conc ~ abs
) %>%
base::summary()
)
}
# Berechnen des Modells
LinMod(abs = Std.mean, conc = conc)
# Berechnen des Modells
LinMod(abs = Std.mean, conc = conc) %>%
pander::pander()
# Berechnen des Modells
LinMod(abs = Std.mean, conc = conc) %>%
kableExtra::kable()
# Berechnen des Modells
LinMod(abs = Std.mean, conc = conc) %>%
kableExtra::kable()
# Berechnen des Modells
LinMod(abs = Std.mean, conc = conc) %>%
knitr::kable()
# Berechnen des Modells
LinMod(abs = Std.mean, conc = conc) %>%
pander::pander()
devtools::install_github("https://github.com/Utzi1/Biotech")
check_dbplyr()
library(Biotech)
llibrary(package)
library(devtools)
install_github("https://github.com/Utzi1/Biotech.git")
knitr::opts_chunk$set(echo = TRUE)
# Berechnen des Modells
LinMod_CEv(abs = Std.mean, conc = conc) %>%
pander::pander()
knitr::opts_chunk$set(echo = TRUE)
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
Std <- tibble(
mes.1 = c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 = c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 = c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 = c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
Std.mean <- rowMeans(Std)
# Berechnen des Modells
LinMod_CEv(abs = Std.mean, conc = conc) %>%
pander::pander()
# Plotten des Modells
plot_regression(abs = Std.mean, conc = conc)
# Berechnen des Modells
LinMod_CEv(abs = Std.mean, conc = conc) %>%
pander::pander()
# Berechnen des Modells
LinModv(abs = Std.mean, conc = conc) %>%
pander::pander()
# Plotten des Modells
plot_regression(abs = Std.mean, conc = conc)
library(Biotech)
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
In diesem Intro werden wir mit dem Paket Biotech arbeiten, dieses installieren wir mit:
```{r , eval = F}
devtools::install_github("https://github.com/Utzi1/Biotech")
```
Installieren müssen wir es nur ein Mal, danach jedoch müssen wir in jedem Skript, in welchem es zum Einsatz kommt, auf seine Existenz verweisen, wir müssen es "laden":
```{r}
library(Biotech)
# Wir laden auch tidverse, dieses Paket enthält eine Menge
# nützlicher Funktionen
library(tidyverse)
```
# Eine Konzentrationsbestimmung
Ihr habt im Labor den Bradfor-Assy durchgeführt und mit Rinderserumalbumin eine Standardreihe aufgenommen, dazu wurden zu jeder Verdünnung vier technische Replikate angefertigt und deren Absorption gemäß der Vorschrift gemessen.
Die Ergebnisse der Messung lauten:
````{r}
Std <- tibble(
mes.1 = c(0.031,	0.092,	0.191,	0.278,	0.332, 0.363),
mes.2 = c(0.04, 0.103, 0.201, 0.279, 0.348, 0.36),
mes.3 = c(0.009, 0.077, 0.166, 0.205, 0.25, 0.397),
mes.4 = c(0.007, 0.084, 0.166, 0.205, 0.353, 0.371),
)
````
Diese fassen wir gleich als tibble zusammen.
Zusätzlich dazu brauchen wir eine Vector, welcher Information über die Konzentration des BSA in den angesetzten Standards bereithält:
```{r}
conc <- seq(
# die geringste Konzentration
from = 0,
# die Höchste Konzentration
to = 100,
# die Länge
length.out =
# diese muss der Anzahl der Messungen entsprechen
length(Std$mes.1)
)
```
Die Länge (also Anzahl der einzelnen Werte muss der Anzahl der Standards entsprechen) wird über das Argument length.out gesteuert.
Als Nächstes berechnen wir das arithmetische Mittel der technischen Replikate:
```{r}
Std.mean <- rowMeans(Std)
```
Damit haben wir nun alles um ein lineares Modell vom Typ $y = m \cdot x + b$ zu errechnen und zu plotten, dies geht recht leicht:
```{r}
# Berechnen des Modells
LinModv(abs = Std.mean, conc = conc) %>%
pander::pander()
# Plotten des Modells
plot_regression(abs = Std.mean, conc = conc)
```
#'
#' This must be performed in advanvce of usage of the function conc_eval to produce a linear model suiteable
#' for concentration evaluation.
#'
#' @param abs list
#' @param conc list
#'
#' @return summary of the regression
#' @export
#'
LinMod <- function(abs, conc) {
mod <- stats::lm(
conc ~ abs
) %>%
base::summary()
return(mod)
}
# Berechnen des Modells
LinModv(abs = Std.mean, conc = conc) %>%
pander::pander()
# Plotten des Modells
plot_regression(abs = Std.mean, conc = conc)
# Berechnen des Modells
LinModv(abs = Std.mean, conc = conc) %>%
pander::pander()
# Berechnen des Modells
LinMod(abs = Std.mean, conc = conc) %>%
pander::pander()
# Plotten des Modells
plot_regression(abs = Std.mean, conc = conc)
mes.1 <- c(0.185, 0.245, 0.399, 0.429, 0.448, 0.431)
setwd(dir = "Bachelor/Biotech/man/")
setwd("..")
devtools::load_all()
library(devtools)
check()
library(outliers)
outlier(conc.2.A)
# rm(list=ls())
# laden von biotech
library(devtools)
load_all(path = "../../Biotech")
library(readxl)
HSA <- read_excel("HSA.xlsx", sheet = "Tabelle2")
HSA <- read_excel("../Beispielauswertungen/HSA_Assay/HSA.xlsx", sheet = "Tabelle2")
summary(HSA)
# 2, 3, 4 sind die Standards
library(tidyverse)
HSA <- mutate(HSA, Std=((HSA$s2 + HSA$s3 + HSA$s4) / 3))
Proben.1 <- c((HSA$s5 + HSA$s6)/2 , (HSA$s7[1:4]+HSA$s8[1:4])/2)
Proben.2 <- c((HSA$s9 + HSA$s10)/2 , (HSA$s7[5:8]+HSA$s8[5:8])/2)
# Es ist bekannt, dass Proben.1 1:5000 verdünnt wurde:
Proben.1 <- Proben.1 * 5000
# Proben.2 wurde 1:1000 Verdünnt
Proben.2 <- Proben.2 * 1000
# Substratkonzentration
subs <- seq(0, 50, length.out = length(HSA$Std))
# Plot der Regression
plot_regression(abs = HSA$Std[2:8], conc = subs[2:8])
# Definition einer einfachen Funktion
cHSA <- function (abs.P) {
conc_eval( abs.P, abs_std = HSA$Std, conc_std = subs)
}
HSA1 <- HSA1
HSA1 <- HSA
use_data(HSA1)
###### ARNO's ELISA ###############################################
HSA.A <- read_excel("../../HSA_Arno.xlsx", sheet = "Tabelle2")
summary(HSA)
###### ARNO's ELISA ###############################################
HSA.A <- read_excel("../../HSA_Arno.xlsx", sheet = "Tabelle2")
###### ARNO's ELISA ###############################################
HSA.A <- read_excel("../Beispielauswertungen/HSA_Arno.xlsx", sheet = "Tabelle2")
HSA2 <- HSA.A
###### ARNO's ELISA ###############################################
HSA.A <- read_excel("../Beispielauswertungen/HSA_Arno.xlsx", sheet = "Tabelle2")
###### ARNO's ELISA ###############################################
HSA.A <- read_excel("../Beispielauswertungen/HSA_Assay/HSA_Arno.xlsx", sheet = "Tabelle2")
summary(HSA)
HSA2 <- HSA.A
use_data(HSA2)
# Laden der Standardreih# Die Werte, welche als Grundlage für die Standardreihe verwendet werden wurden
# hierbei noch verändert, es wird angenommen, dass die Spalte MW Werte auslässt,
# welche den Mittelwert zu stark verfälschene
library(readxl)
STR1 <- read_excel("ProgesteronVK.xlsx",
sheet = "Tabelle2", col_names = FALSE)
str(STR1)
# Laden von Biotech
library(devtools)
daisy <- read_csv2("../Beispielauswertungen/fermentation/Daisy.csv")
plot( y = daisy$`STIRR [rpm]`[240:328], x = daisy$Time[240:328], "l" )
use_data(daisy)
